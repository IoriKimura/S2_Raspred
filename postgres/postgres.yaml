---
apiVersion: v1
kind: Namespace
metadata:
  name: dbs
---
apiVersion: v1
kind: Secret
metadata:
  name: pg-secrets
  namespace: dbs
type: Opaque
stringData:
  POSTGRES_PASSWORD_A: "passwordA"
  POSTGRES_PASSWORD_B: "passwordB"
  REPLICATOR_PASSWORD: "replicator_pass"
  #FDW_READER_PASSWORD: "fdw_reader_pass"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-a-init-sql
  namespace: dbs
data:
  01-init.sql: |
    CREATE TABLE IF NOT EXISTS a_table1 (
        id serial PRIMARY KEY,
        info text,
        created_at timestamptz DEFAULT now()
    );
    CREATE TABLE IF NOT EXISTS a_table2 (
        id serial PRIMARY KEY,
        value integer,
        created_at timestamptz DEFAULT now()
    );
    INSERT INTO a_table1 (info) VALUES ('First_value'),('Second_value'),('Third_value') ON CONFLICT DO NOTHING;
    INSERT INTO a_table2 (value) VALUES (100),(200),(300) ON CONFLICT DO NOTHING;

    -- Прикладной пользователь A
    CREATE ROLE user_a LOGIN PASSWORD 'user_a_pass';

    -- Привилегии
    REVOKE ALL ON SCHEMA public FROM PUBLIC;
    GRANT USAGE ON SCHEMA public TO user_a;
    GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO user_a;
    GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO user_a;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO user_a;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO user_a;

    -- Пользователь для FDW-чтения с B
    CREATE ROLE fdw_reader LOGIN PASSWORD 'fdw_reader_pass';
    GRANT CONNECT ON DATABASE db_a TO fdw_reader;
    GRANT USAGE ON SCHEMA public TO fdw_reader;
    GRANT SELECT ON a_table1, a_table2 TO fdw_reader;

    -- Пользователь для репликации
    CREATE ROLE replicator LOGIN REPLICATION PASSWORD 'replicator_pass';
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-a-config
  namespace: dbs
data:
  postgresql.conf: |
    # Настройки для репликации
    wal_level = replica
    max_wal_senders = 10
    max_replication_slots = 10
    hot_standby = on
    listen_addresses = '*'
    port = 5432
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-b-init-sql
  namespace: dbs
data:
  01-init.sql: |
    CREATE TABLE IF NOT EXISTS b_table1 (
        id serial PRIMARY KEY,
        note text,
        created_at timestamptz DEFAULT now()
    );
    CREATE TABLE IF NOT EXISTS b_table2 (
        id serial PRIMARY KEY,
        amount numeric,
        created_at timestamptz DEFAULT now()
    );
    INSERT INTO b_table1 (note) VALUES ('some1'),('some2') ON CONFLICT DO NOTHING;
    INSERT INTO b_table2 (amount) VALUES (12.5),(34.0) ON CONFLICT DO NOTHING;

    -- Прикладной пользователь B
    CREATE ROLE user_b LOGIN PASSWORD 'user_b_pass';
    REVOKE ALL ON SCHEMA public FROM PUBLIC;
    GRANT USAGE ON SCHEMA public TO user_b;
    GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO user_b;
    GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO user_b;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO user_b;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO user_b;

    -- ---------- FDW к Postgres-A ----------
    CREATE EXTENSION IF NOT EXISTS postgres_fdw;

    -- Внешний сервер указывает на сервис A
    CREATE SERVER IF NOT EXISTS server_a
      FOREIGN DATA WRAPPER postgres_fdw
      OPTIONS (host 'postgres-a-svc', port '5432', dbname 'db_a');

    -- ВАЖНО: мэппинг для postgres (init-скрипт выполняется под суперпользователем)
    CREATE USER MAPPING IF NOT EXISTS FOR postgres
      SERVER server_a OPTIONS (user 'fdw_reader', password 'fdw_reader_pass');

    -- Мэппинг для прикладного пользователя
    CREATE USER MAPPING IF NOT EXISTS FOR user_b
      SERVER server_a OPTIONS (user 'fdw_reader', password 'fdw_reader_pass');

    -- Импорт внешних таблиц из A (в схему public B)
    IMPORT FOREIGN SCHEMA public LIMIT TO (a_table1, a_table2)
      FROM SERVER server_a INTO public;

    -- Права на импортированные foreign tables и доступ к серверу
    GRANT USAGE ON SCHEMA public TO user_b;
    GRANT SELECT ON a_table1, a_table2 TO user_b;
    GRANT USAGE ON FOREIGN SERVER server_a TO user_b;

    -- Пользователь для репликации
    CREATE ROLE replicator LOGIN REPLICATION PASSWORD 'replicator_pass';
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-b-config
  namespace: dbs
data:
  postgresql.conf: |
    # Настройки для репликации
    wal_level = replica
    max_wal_senders = 10
    max_replication_slots = 10
    hot_standby = on
    listen_addresses = '*'
    port = 5432
---
# -------------------------------
# POSTGRES-A STATEFULSET (с репликацией)
# -------------------------------
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-a
  namespace: dbs
spec:
  serviceName: postgres-a-headless
  replicas: 3  # 1 master + 2 replicas
  selector:
    matchLabels:
      app: postgres-a
  template:
    metadata:
      labels:
        app: postgres-a
    spec:
      initContainers:
      # Init container для настройки репликации (только для replicas)
      - name: setup-replication
        image: postgres:15
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: REPLICATOR_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pg-secrets
              key: REPLICATOR_PASSWORD
        command:
        - /bin/bash
        - -c
        - |
          # Если это не master (не первый под), настраиваем replica
          if [[ "$POD_NAME" != "postgres-a-0" ]]; then
            echo "Настройка replica для $POD_NAME"
            
            # Ждем готовности master
            MASTER_HOST="postgres-a-0.postgres-a-headless.dbs.svc.cluster.local"
            until pg_isready -h "$MASTER_HOST" -p 5432 -U replicator; do
              echo "Ожидание готовности master..."
              sleep 2
            done
            
            # Если данные уже есть, пропускаем настройку
            if [ -f /var/lib/postgresql/data/PG_VERSION ]; then
              echo "Данные уже существуют, пропускаем настройку replica"
              exit 0
            fi
            
            # Создаем backup для репликации
            echo "Создание backup с master..."
            PGPASSWORD="$REPLICATOR_PASSWORD" pg_basebackup \
              -h "$MASTER_HOST" \
              -p 5432 \
              -U replicator \
              -D /var/lib/postgresql/data \
              -Fp \
              -Xs \
              -P \
              -R
            
            echo "Replica настроена успешно"
          else
            echo "Это master, пропускаем настройку replica"
          fi
        volumeMounts:
        - name: pgdata
          mountPath: /var/lib/postgresql/data
      containers:
      - name: postgres
        image: postgres:15
        env:
        - name: POSTGRES_DB
          value: "db_a"
        - name: POSTGRES_USER
          value: "postgres"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pg-secrets
              key: POSTGRES_PASSWORD_A
        - name: REPLICATOR_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pg-secrets
              key: REPLICATOR_PASSWORD
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        ports:
        - containerPort: 5432
          name: postgres
        volumeMounts:
        - name: pgdata
          mountPath: /var/lib/postgresql/data
        - name: init-sql
          mountPath: /docker-entrypoint-initdb.d
        - name: postgres-config
          mountPath: /etc/postgresql
        # Настройка репликации после запуска (для master)
        lifecycle:
          postStart:
            exec:
              command:
              - /bin/bash
              - -c
              - |
                if [[ "$POD_NAME" == "postgres-a-0" ]]; then
                  # Ждем готовности PostgreSQL
                  until pg_isready -U postgres; do sleep 1; done
                  sleep 5
                  
                  # Применяем конфигурацию из ConfigMap (если еще не применена)
                  if [ -f /etc/postgresql/postgresql.conf ]; then
                    # Добавляем настройки из ConfigMap в postgresql.conf
                    while IFS= read -r line; do
                      if [[ ! "$line" =~ ^#.*$ ]] && [[ -n "$line" ]]; then
                        KEY=$(echo "$line" | cut -d'=' -f1 | xargs)
                        if ! grep -q "^${KEY}" /var/lib/postgresql/data/postgresql.conf; then
                          echo "$line" >> /var/lib/postgresql/data/postgresql.conf
                        fi
                      fi
                    done < /etc/postgresql/postgresql.conf
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT pg_reload_conf();" || true
                  fi
                  
                  # Настраиваем pg_hba.conf для репликации
                  if ! grep -q "host replication replicator" /var/lib/postgresql/data/pg_hba.conf; then
                    echo "host replication replicator 0.0.0.0/0 scram-sha-256" >> /var/lib/postgresql/data/pg_hba.conf
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT pg_reload_conf();" || true
                  fi
                  
                  # Создаем replication slots для каждой replica
                  for i in 1 2; do
                    SLOT_NAME="replica_${i}"
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT 1 FROM pg_replication_slots WHERE slot_name='$SLOT_NAME';" | grep -q 1 || \
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT pg_create_physical_replication_slot('$SLOT_NAME');" || true
                  done
                fi
      volumes:
      - name: init-sql
        configMap:
          name: postgres-a-init-sql
          defaultMode: 0644
      - name: postgres-config
        configMap:
          name: postgres-a-config
  volumeClaimTemplates:
  - metadata:
      name: pgdata
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 2Gi
---
# -------------------------------
# POSTGRES-B STATEFULSET (с репликацией, ожидание A)
# -------------------------------
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-b
  namespace: dbs
spec:
  serviceName: postgres-b-headless
  replicas: 3  # 1 master + 2 replicas
  selector:
    matchLabels:
      app: postgres-b
  template:
    metadata:
      labels:
        app: postgres-b
    spec:
      initContainers:
      - name: wait-for-a
        image: postgres:15
        command:
          - sh
          - -c
          - |
            until pg_isready -h postgres-a-svc -p 5432 -q; do
              echo "waiting for postgres-a";
              sleep 2;
            done
      # Init container для настройки репликации (только для replicas)
      - name: setup-replication
        image: postgres:15
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: REPLICATOR_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pg-secrets
              key: REPLICATOR_PASSWORD
        command:
        - /bin/bash
        - -c
        - |
          # Если это не master (не первый под), настраиваем replica
          if [[ "$POD_NAME" != "postgres-b-0" ]]; then
            echo "Настройка replica для $POD_NAME"
            
            # Ждем готовности master
            MASTER_HOST="postgres-b-0.postgres-b-headless.dbs.svc.cluster.local"
            until pg_isready -h "$MASTER_HOST" -p 5432 -U replicator; do
              echo "Ожидание готовности master..."
              sleep 2
            done
            
            # Если данные уже есть, пропускаем настройку
            if [ -f /var/lib/postgresql/data/PG_VERSION ]; then
              echo "Данные уже существуют, пропускаем настройку replica"
              exit 0
            fi
            
            # Создаем backup для репликации
            echo "Создание backup с master..."
            PGPASSWORD="$REPLICATOR_PASSWORD" pg_basebackup \
              -h "$MASTER_HOST" \
              -p 5432 \
              -U replicator \
              -D /var/lib/postgresql/data \
              -Fp \
              -Xs \
              -P \
              -R
            
            echo "Replica настроена успешно"
          else
            echo "Это master, пропускаем настройку replica"
          fi
        volumeMounts:
        - name: pgdata
          mountPath: /var/lib/postgresql/data
      containers:
      - name: postgres
        image: postgres:15
        env:
        - name: POSTGRES_DB
          value: "db_b"
        - name: POSTGRES_USER
          value: "postgres"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pg-secrets
              key: POSTGRES_PASSWORD_B
        - name: REPLICATOR_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pg-secrets
              key: REPLICATOR_PASSWORD
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        ports:
        - containerPort: 5432
          name: postgres
        volumeMounts:
        - name: pgdata
          mountPath: /var/lib/postgresql/data
        - name: init-sql
          mountPath: /docker-entrypoint-initdb.d
        - name: postgres-config
          mountPath: /etc/postgresql
        # Настройка репликации после запуска (для master)
        lifecycle:
          postStart:
            exec:
              command:
              - /bin/bash
              - -c
              - |
                if [[ "$POD_NAME" == "postgres-b-0" ]]; then
                  # Ждем готовности PostgreSQL
                  until pg_isready -U postgres; do sleep 1; done
                  sleep 5
                  
                  # Применяем конфигурацию из ConfigMap (если еще не применена)
                  if [ -f /etc/postgresql/postgresql.conf ]; then
                    # Добавляем настройки из ConfigMap в postgresql.conf
                    while IFS= read -r line; do
                      if [[ ! "$line" =~ ^#.*$ ]] && [[ -n "$line" ]]; then
                        KEY=$(echo "$line" | cut -d'=' -f1 | xargs)
                        if ! grep -q "^${KEY}" /var/lib/postgresql/data/postgresql.conf; then
                          echo "$line" >> /var/lib/postgresql/data/postgresql.conf
                        fi
                      fi
                    done < /etc/postgresql/postgresql.conf
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT pg_reload_conf();" || true
                  fi
                  
                  # Настраиваем pg_hba.conf для репликации
                  if ! grep -q "host replication replicator" /var/lib/postgresql/data/pg_hba.conf; then
                    echo "host replication replicator 0.0.0.0/0 scram-sha-256" >> /var/lib/postgresql/data/pg_hba.conf
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT pg_reload_conf();" || true
                  fi
                  
                  # Создаем replication slots для каждой replica
                  for i in 1 2; do
                    SLOT_NAME="replica_${i}"
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT 1 FROM pg_replication_slots WHERE slot_name='$SLOT_NAME';" | grep -q 1 || \
                    PGPASSWORD="$POSTGRES_PASSWORD" psql -U postgres -c "SELECT pg_create_physical_replication_slot('$SLOT_NAME');" || true
                  done
                fi
      volumes:
      - name: init-sql
        configMap:
          name: postgres-b-init-sql
          defaultMode: 0644
      - name: postgres-config
        configMap:
          name: postgres-b-config
  volumeClaimTemplates:
  - metadata:
      name: pgdata
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 2Gi
---
# -------------------------------
# SERVICES
# -------------------------------
# Headless Service для StatefulSet postgres-a (для прямого доступа к подам)
apiVersion: v1
kind: Service
metadata:
  name: postgres-a-headless
  namespace: dbs
spec:
  clusterIP: None
  selector:
    app: postgres-a
  ports:
    - port: 5432
      targetPort: 5432
      name: postgres
---
# Service для master postgres-a (указывает на первый под)
apiVersion: v1
kind: Service
metadata:
  name: postgres-a-svc
  namespace: dbs
spec:
  selector:
    app: postgres-a
    statefulset.kubernetes.io/pod-name: postgres-a-0
  ports:
    - port: 5432
      targetPort: 5432
      name: postgres
  type: ClusterIP
---
# Headless Service для StatefulSet postgres-b (для прямого доступа к подам)
apiVersion: v1
kind: Service
metadata:
  name: postgres-b-headless
  namespace: dbs
spec:
  clusterIP: None
  selector:
    app: postgres-b
  ports:
    - port: 5432
      targetPort: 5432
      name: postgres
---
# Service для master postgres-b (указывает на первый под)
apiVersion: v1
kind: Service
metadata:
  name: postgres-b-svc
  namespace: dbs
spec:
  selector:
    app: postgres-b
    statefulset.kubernetes.io/pod-name: postgres-b-0
  ports:
    - port: 5432
      targetPort: 5432
      name: postgres
  type: ClusterIP
